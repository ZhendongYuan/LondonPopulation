---
title: "ULB_urban_2_adapted"
author: "zhendong yuan"
date: "2019/11/12"
output: html_document
---

```{r setup, results='hide', message=FALSE, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library("reshape2")
library("BBmisc")
library("densratio")
library("h2o")
library("rsample")

library("rgdal")
library("sp")
library("dplyr")
library("Metrics")
```

# to reproduce the methods provide in ULB paper, which use urban atlas as the lulc informaiton source and random forest to set the ratio of classes as the predictors.
```{r}
ulb_raw_features = read.csv("/data/zhendongBackup/london/20191213/ULB_ATLAS/ulb_raw_features.csv")
```

# for each moa object, complete the features by match the class name.
```{r}
moa_features_ULB = dcast(ulb_raw_features,msoa11cd~class_name,value.var = "area_ratio",sum)
# merge population to this varaibles.
moa_pop = get(load("/data/zhendongBackup/london/20191213/Rspace/pop/raw_pop_mid_london.Rdata"))
colnames(moa_pop)

moa_features_ULB_pop = merge(moa_features_ULB,moa_pop[c("AreaCodes","population")],by.x = "msoa11cd", by.y= "AreaCodes")
# normalize pop
moa_features_ULB_pop$population = normalize(moa_features_ULB_pop$population,method = "range",range = c(0, 1))

summary(moa_features_ULB_pop)
moa_data = subset(moa_features_ULB_pop,select = -c(msoa11cd))
colnames(moa_data)
```


# prepare the sbl features
```{r}
sbl_data_features= read.csv("/data/zhendongBackup/london/20191213/ULB_ATLAS/ulb_raw_features_sbl.csv")
colnames(sbl_data_features)


dim(sbl_data_features)
sbl_features_ULB = dcast(sbl_data_features,sbl_id~class_name,value.var = "area_ratio",sum,fill = 0)
dim(sbl_features_ULB)
summary(sbl_features_ULB)

sbl_data = subset(sbl_features_ULB,select = -c(sbl_id))

colnames(sbl_data)
```



```{r}
source_data_dropPop  = moa_data
source_data_dropPop$population = NULL

target_data_dropPop = sbl_data
```
# get the restio
```{r}
#densratio_obj_uLSIF <- densratio(source_data_dropPop,target_data_dropPop,method = "RuLSIF")
#density_ratio = densratio_obj_uLSIF$compute_density_ratio(source_data_dropPop)
density_ratio = get(load("/data/zhendongBackup/london/20191213/ULB_ATLAS/ULB_moa2sbl_weights_RuLSIF.Rdata"))
summary(density_ratio)
plot(density(density_ratio))

#save(density_ratio, file= "/home/z/zhendong/london/ULB_ATLAS/ULB_moa2sbl_weights_RuLSIF.Rdata")
```

# weighted model which trained and fine-tuned from moa
```{r}
# load loa and moa
source_data = moa_data
source_data["weights"] = density_ratio


source_data_split <- initial_split(source_data, prop = .8)
source_data_train <- training(source_data_split)
source_data_test  <- testing(source_data_split)
source_data = NULL

h2o.no_progress()
h2o.init(max_mem_size = "10g")
source_moa_train.h2o <- as.h2o(source_data_train)
y <- "population"
x <- setdiff(names(source_moa_train.h2o), y)
# train final model
h2o.final <- h2o.randomForest(
  
  x = x,
  y = y,
  
  training_frame = source_moa_train.h2o,
  weights_column = "weights",



 nfolds = 5,


mtries = 4,
  nbins = 30,
   ntrees = 4100, 
  max_depth = 10,
  sample_rate = 0.75,
  stopping_rounds = 20

)

# model stopped after xx trees
h2o.final@parameters$ntrees

# cross validated RMSE
h2o.rmse(h2o.final, xval = TRUE)

# plot model.
h2o.final
```


# varaibles important
```{r}
h2o.varimp_plot(h2o.final, num_of_features = 15)

h2o.final@model$variable_importances$variable = "test"

```

# weighted model predict on moa level. validat in testing dataset
```{r}
source_data_test$weights = NULL
source_data_test.h2o <- as.h2o(source_data_test)
h2o.performance(model = h2o.final, newdata = source_data_test.h2o)
source_data_test_population = source_data_test$population
source_data_test$population = NULL
source_data_test.h2o <- as.h2o(source_data_test)
# evaluate performance on loa
source_data_test_predict = as.data.frame(h2o.predict(h2o.final, source_data_test.h2o))
source_data_test["population"] = source_data_test_population
```

```{r}
predict_pop = source_data_test_predict$predict
real_pop =  source_data_test$population

# rmse
rmse(real_pop,predict_pop)

# %rmse
(rmse(real_pop,predict_pop)*length(real_pop))/sum(real_pop)

#mae
mae(real_pop,predict_pop)

# %mae
(mae(real_pop,predict_pop) * length(real_pop))/sum(real_pop)
```


# weighted model adapted applied to data at sbl level with scaled prediction
```{r}
target_data = sbl_data
colnames(target_data)
target.loa.h2o <- as.h2o(target_data)
sb_transferred_predict = as.data.frame(h2o.predict(h2o.final, target.loa.h2o))
plot(density(sb_transferred_predict$predict))

```


# denormonised by the constraints of population sum.
```{r}

sb_shape <- readOGR("/home/z/zhendong/london/ULB_ATLAS/street_blocksl_withinloa_gid.shp")

sbl_predicted_data = data.frame(pred_sbl_pop=sb_transferred_predict$predict, sb_id = sbl_features_ULB$sbl_id)

sbl_predicted_data_df = merge(sbl_predicted_data,sb_shape@data[c("SBL_ID","LSOA11CD")],by.x = "sb_id", by.y= "SBL_ID", all.x = TRUE)
colnames(sbl_predicted_data_df)

london_low <- readOGR("/home/z/zhendong/london/LSOA_2011_London_3857.shp")
london_low_df = london_low@data[,c(1,3)]

sbl_predicted_df_lm = merge(sbl_predicted_data_df,london_low_df, by= "LSOA11CD", all.x = TRUE)

# by the sum of numbers
moa_or_data= get(load("/home/z/zhendong/london/Rspace/moa_data.Rdata"))
sum_or_pop = sum(moa_or_data$population)
print("sum true pop")
sum_or_pop
sum_sb_transferred_predict = sum(sbl_predicted_df_lm$pred_sbl_pop)
rough_ratio_red = sum_or_pop/sum_sb_transferred_predict
# ratio transferred
print("ratio transferred")
rough_ratio_red

sbl_predicted_df_lm$pred_sbl_pop = sbl_predicted_df_lm$pred_sbl_pop*rough_ratio_red
print("sum up descaled sb predicted pop")
sum(sbl_predicted_df_lm$pred_sbl_pop)



temp_final = merge(sb_shape@data,sbl_predicted_df_lm[,c("pred_sbl_pop","pred_sbl_pop","sb_id")],by.x = "SBL_ID",by.y="sb_id",all.x=TRUE)

sb_shape@data=temp_final
#writeOGR(sb_shape,dsn ="/home/z/zhendong/london/ULB_ATLAS",layer = "predicted_adj_sbl_adapted_2",driver = "ESRI Shapefile")
```

# plot the distribtution of sbl
```{r}
summary(sbl_predicted_df_lm$pred_adj_pop)
plot(density(sbl_predicted_df_lm$pred_sbl_pop))
```

# aggreagete to loa and output the aggregated value on loa and the spatial residual
```{r}
# aggreagete to loa
sbl_predicted_df_adj_loa = sbl_predicted_df_lm %>% 
  group_by(LSOA11CD) %>% 
  summarise(pred_loa_pop = sum(pred_sbl_pop))

# merge with true pop in loa 
raw_pop_loa= get(load("/home/z/zhendong/london/Rspace/pop/raw_pop_london_low.Rdata"))
raw_pop_loa["LSOA11CD"] = raw_pop_loa$AreaCodes
sbl_predicted_df_adj_loa = merge(sbl_predicted_df_adj_loa,raw_pop_loa, by= "LSOA11CD", all.x = TRUE)
colnames(sbl_predicted_df_adj_loa)
sbl_predicted_df_adj_loa = sbl_predicted_df_adj_loa[,c(1:5)]


colnames(sbl_predicted_df_adj_loa)[5] = "loa_true_pop"
sbl_predicted_df_adj_loa["residual"] = sbl_predicted_df_adj_loa$loa_true_pop-sbl_predicted_df_adj_loa$pred_loa_pop
summary(sbl_predicted_df_adj_loa)

london_low_shp = merge(sbl_predicted_df_adj_loa,london_low@data,by = "LSOA11CD",all.y= TRUE)
london_low@data = london_low_shp
#writeOGR(london_low,dsn ="/home/z/zhendong/london/ULB_ATLAS",layer = "predicted_adj_sbl_loa_adapted_2",driver = "ESRI Shapefile")
```

#3.  esitmate accuracy 
```{r}
predict_pop = sbl_predicted_df_adj_loa$pred_loa_pop
real_pop =  sbl_predicted_df_adj_loa$loa_true_pop

# rmse
rmse(real_pop,predict_pop)

# %rmse
(rmse(real_pop,predict_pop)*length(real_pop))/sum(real_pop)

#mae
mae(real_pop,predict_pop)

# %mae
(mae(real_pop,predict_pop) * length(real_pop))/sum(real_pop)
```
#3 visualize predicted pop and the real one  
```{r}

plot(density(sbl_predicted_df_adj_loa$loa_true_pop),col="black")+
lines(density(sbl_predicted_df_adj_loa$pred_loa_pop),col="red")
```

# plot the statistic residual
```{r}
plot(density(sbl_predicted_df_adj_loa$loa_true_pop-sbl_predicted_df_adj_loa$pred_loa_pop),col="black")
```



